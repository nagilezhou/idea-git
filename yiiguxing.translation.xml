<application>
  <component name="AppStorage">
    <histories>
      <item value="&lt;li&gt;Allows shorthand mock and spy injection.&lt;li&gt; &lt;li&gt;Minimizes repetitive mock and spy injection.&lt;li&gt; &lt;ul&gt; &lt;p&gt; Mockito will try to inject mocks only either by constructor injection, setter injection, or property injection in order and as described below. If any of the following strategy fail, then Mockito &lt;strong&gt;won't report failure&lt;strong&gt;; i.e. you will have to provide dependencies yourself. &lt;ol&gt; &lt;li&gt;&lt;strong&gt;Constructor injection&lt;strong&gt;; the biggest constructor is chosen, then arguments are resolved with mocks declared in the test only. If the object is successfully created with the constructor, then &lt;strong&gt;Mockito won't try the other strategies&lt;strong&gt;. Mockito has decided to no corrupt an object if it has a parametered constructor. &lt;p&gt;&lt;u&gt;Note:&lt;u&gt; If arguments can not be found, then null is passed. If non-mockable types are wanted, then constructor injection won't happen. In these cases, you will have to satisfy dependencies yourself.&lt;p&gt;&lt;li&gt; &lt;li&gt;&lt;strong&gt;Property setter injection&lt;strong&gt;; mocks will first be resolved by type (if a single type match injection will happen regardless of the name), then, if there is several property of the same type, by the match of the property name and the mock name. &lt;p&gt;&lt;u&gt;Note 1:&lt;u&gt; If you have properties with the same type (or same erasure), it's better to name all &amp;064;Mock annotated fields with the matching properties, otherwise Mockito might get confused and injection won't happen.&lt;p&gt; &lt;p&gt;&lt;u&gt;Note 2:&lt;u&gt; If &amp;064;InjectMocks instance wasn't initialized before and have a no-arg constructor, then it will be initialized with this constructor.&lt;p&gt;&lt;li&gt; &lt;li&gt;&lt;strong&gt;Field injection&lt;strong&gt;; mocks will first be resolved by type (if a single type match injection will happen regardless of the name), then, if there is several property of the same type, by the match of the field name and the mock name. &lt;p&gt;&lt;u&gt;Note 1:&lt;u&gt; If you have fields with the same type (or same erasure), it's better to name all &amp;064;Mock annotated fields with the matching fields, otherwise Mockito might get confused and injection won't happen.&lt;p&gt; &lt;p&gt;&lt;u&gt;Note 2:&lt;u&gt; If &amp;064;InjectMocks instance wasn't initialized before and have a no-arg constructor, then it will be initialized with this constructor.&lt;p&gt;&lt;li&gt; &lt;ol&gt;" />
      <item value="In the above example the field &lt;code&gt;ArticleManager&lt;code&gt; annotated with &lt;code&gt;&amp;064;InjectMocks&lt;code&gt; can have a parameterized constructor only or a no-arg constructor only, or both. All these constructors can be package protected, protected or private, however &lt;u&gt;Mockito cannot instantiate inner classes, local classes, abstract classes and of course interfaces.&lt;u&gt; &lt;u&gt;Beware of private nest static classes too.&lt;u&gt; &lt;p&gt;The same stands for setters or fields, they can be declared with private visibility, Mockito will see them through reflection. However fields that are static or final will be ignored.&lt;p&gt; &lt;p&gt;So on the field that needs injection, for example constructor injection will happen here :&lt;p&gt;" />
      <item value="Returns true if the connection has not been closed and is still valid. The driver shall submit a query on the connection or use some other mechanism that positively verifies the connection is still valid when this method is called. &lt;p&gt; The query submitted by the driver to validate the connection shall be executed in the context of the current transaction. @param timeout - The time in seconds to wait for the database operation used to validate the connection to complete. If the timeout period expires before the operation completes, this method returns false. A value of 0 indicates a timeout is not applied to the database operation." />
      <item value="Don't allow anyone to instantiate an AccessController private AccessController() { } Performs the specified {@code PrivilegedAction} with privileges enabled. The action is performed with &lt;i&gt;all&lt;i&gt; of the permissions possessed by the caller's protection domain. &lt;p&gt; If the action's {@code run} method throws an (unchecked) exception, it will propagate through this method. &lt;p&gt; Note that any DomainCombiner associated with the current AccessControlContext will be ignored while the action is performed. @param &lt;T&gt; the type of the value returned by the PrivilegedAction's {@code run} method. @param action the action to be performed. @return the value returned by the action's {@code run} method. @exception NullPointerException if the action is {@code null}" />
      <item value="Retrieves whether the driver thinks that it can open a connection to the given URL. Typically drivers will return &lt;code&gt;true&lt;code&gt; if they understand the sub-protocol specified in the URL and &lt;code&gt;false&lt;code&gt; if they do not." />
      <item value="local Unit Flag" />
      <item value="Registers the supplied transformer. All future class definitions will be seen by the transformer, except definitions of classes upon which any registered transformer is dependent. The transformer is called when classes are loaded, when they are {@linkplain redefineClasses redefined}. and if &lt;code&gt;canRetransform&lt;code&gt; is true, when they are {@linkplain retransformClasses retransformed}. See {@link java.lang.instrument.ClassFileTransformertransform ClassFileTransformer.transform} for the order of transform calls. If a transformer throws an exception during execution, the JVM will still call the other registered transformers in order. The same transformer may be added more than once, but it is strongly discouraged -- avoid this by creating a new instance of transformer class. &lt;P&gt; This method is intended for use in instrumentation, as described in the {@linkplain Instrumentation class specification}." />
      <item value="Finds all the resources with the given name. A resource is some data (images, audio, text, etc) that can be accessed by class code in a way that is independent of the location of the code. &lt;p&gt;The name of a resource is a &lt;tt&gt;&lt;tt&gt;-separated path name that identifies the resource. &lt;p&gt; The search order is described in the documentation for {@link getResource(String)}. &lt;p&gt; @apiNote When overriding this method it is recommended that an implementation ensures that any delegation is consistent with the {@link getResource(java.lang.String) getResource(String)} method. This should ensure that the first element returned by the Enumeration's {@code nextElement} method is the same resource that the {@code getResource(String)} method would return. @param name The resource name @return An enumeration of {@link java.net.URL &lt;tt&gt;URL&lt;tt&gt;} objects for the resource. If no resources could be found, the enumeration will be empty. Resources that the class loader doesn't have access to will not be in the enumeration." />
      <item value="This class provides services needed to instrument Java programming language code. Instrumentation is the addition of byte-codes to methods for the purpose of gathering data to be utilized by tools. Since the changes are purely additive, these tools do not modify application state or behavior. Examples of such benign tools include monitoring agents, profilers, coverage analyzers, and event loggers. &lt;P&gt; There are two ways to obtain an instance of the &lt;code&gt;Instrumentation&lt;code&gt; interface: &lt;ol&gt; &lt;li&gt;&lt;p&gt; When a JVM is launched in a way that indicates an agent class. In that case an &lt;code&gt;Instrumentation&lt;code&gt; instance is passed to the &lt;code&gt;premain&lt;code&gt; method of the agent class. &lt;p&gt;&lt;li&gt; &lt;li&gt;&lt;p&gt; When a JVM provides a mechanism to start agents sometime after the JVM is launched. In that case an &lt;code&gt;Instrumentation&lt;code&gt; instance is passed to the &lt;code&gt;agentmain&lt;code&gt; method of the agent code. &lt;p&gt; &lt;li&gt; &lt;ol&gt; &lt;p&gt; These mechanisms are described in the {@linkplain java.lang.instrument package specification}. &lt;p&gt; Once an agent acquires an &lt;code&gt;Instrumentation&lt;code&gt; instance, the agent may call methods on the instance at any time." />
      <item value="Skip processing directly once interceptor returns false." />
      <item value="true if interceptor chain is allowed to proceed; false otherwise." />
      <item value="Execute hook-in logic after business processing. Potential execution result can be acquired through inspecting" />
      <item value="Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum. The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes). Example 1: Input: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8 Output: 3 Explanation: The paths that sum to 8 are shown. Example 2: Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 Output: 3" />
      <item value="Given a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temper ature. If there is no future day for which this is possible, put 0 instead. For example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76, 7 3], your output should be [1, 1, 4, 2, 1, 1, 0, 0]." />
      <item value="is Equal Collection" />
      <item value="Compares the specified object with this set for equality. Returns * &lt;tt&gt;true&lt;/tt&gt; if the specified object is also a set, the two sets * have the same size, and every member of the specified set is * contained in this set (or equivalently, every member of this set is * contained in the specified set). This definition ensures that the * equals method works properly across different implementations of the * set interface." />
      <item value="delegate" />
      <item value="asynchronous" />
      <item value="maintain" />
      <item value="Number of INSERT target columns (7) does not equal number of source items (6)." />
      <item value="repetition" />
      <item value="AND IS_DELETED = 0" />
      <item value="To report security vulnerabilities" />
      <item value="subarray" />
      <item value="contiguous" />
      <item value="conquer approach" />
      <item value="approach" />
      <item value="conquer" />
      <item value="try coding another solu //tion using the divide and conquer approach, which is more subtle." />
      <item value="he Abstract Factory pattern provides a way to encapsulate a group of individual factories that * have a common theme without specifying their concrete classes. In normal usage, the client * software creates a concrete implementation of the abstract factory and then uses the generic * interface of the factory to create the concrete objects that are part of the theme. The client * does not know (or care) which concrete objects it gets from each of these internal factories, * since it uses only the generic interfaces of their products. This pattern separates the details * of implementation of a set of objects from their general usage and relies on object composition, * as object creation is implemented in methods exposed in the factory interface. * * &lt;p&gt;The essence of the Abstract Factory pattern is a factory interface ({@link KingdomFactory}) * and its implementations ( {@link ElfKingdomFactory}, {@link OrcKingdomFactory}). The example uses * both concrete implementations to create a king, a castle and an army." />
      <item value="Facade" />
      <item value="arguments" />
      <item value="Recovery Strategy Tolerance" />
      <item value="Recovery Strategy Field" />
      <item value="Tolerance" />
      <item value="Assign" />
      <item value="without making a copy" />
      <item value="Internally you can think of this" />
      <item value="which means a modificati //on to the input array will be known to the caller as well." />
      <item value="Note that the input array is passed in by reference" />
      <item value="Confused why the returned value is an integer but your answer is an array?" />
      <item value="Confused" />
      <item value="Clarification" />
      <item value="//Given a sorted array nums, remove the duplicates in-place such that each eleme //nt appears only once and returns the new length." />
      <item value="//Given a sorted array nums, remove the duplicates in-place such that each eleme //nt appears only once and returns the new length. // // Do not allocate extra space for another array, you must do this by modifying //the input array in-place with O(1) extra memory. // // Clarification: // // Confused why the returned value is an integer but your answer is an array? // // Note that the input array is passed in by reference, which means a modificati //on to the input array will be known to the caller as well. // // Internally you can think of this: // // //// nums is passed in by reference. (i.e., without making a copy) //int len = removeDuplicates(nums); // //// any modification to nums in your function would be known by the caller. //// using the length returned by your function, it prints the first len element //s. //for (int i = 0; i &lt; len; i++) { //    print(nums[i]); //} // // // Example 1: // // //Input: nums = [1,1,2] //Output: 2, nums = [1,2] //Explanation: Your function should return length = 2, with the first two elemen //ts of nums being 1 and 2 respectively. It doesn't matter what you leave beyond t //he returned length. // // // Example 2: // // //Input: nums = [0,0,1,1,1,2,2,3,3,4] //Output: 5, nums = [0,1,2,3,4] //Explanation: Your function should return length = 5, with the first five eleme //nts of nums being modified to 0, 1, 2, 3, and 4 respectively. It doesn't matter //what values are set beyond the returned length. // // // // Constraints: // // // 0 &lt;= nums.length &lt;= 3 * 104 // -104 &lt;= nums[i] &lt;= 104 // nums is sorted in ascending order. // // Related Topics 数组 双指针 //  1714  0" />
      <item value="Guard" />
      <item value="Definition" />
      <item value="Assembler" />
      <item value="Constraints:" />
      <item value="/Given an array of integers nums and an integer target, return indices of the t //wo numbers such that they add up to target." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="55" />
        <entry key="ENGLISH" value="57" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1641453936181" />
  </component>
  <component name="Translation.Cache">
    <option name="lastTrimTime" value="1684115094474" />
  </component>
  <component name="Translation.States">
    <option name="newTranslationDialogHeight" value="247" />
    <option name="newTranslationDialogWidth" value="558" />
    <option name="newTranslationDialogX" value="770" />
    <option name="newTranslationDialogY" value="445" />
    <histories>
      <item value="hard earned" />
      <item value="不能吃" />
      <item value="难吃" />
      <item value="难以下咽" />
      <item value="overcooked" />
      <item value="rubbery" />
      <item value="橡胶" />
      <item value="until then" />
      <item value="dog bag" />
      <item value="runny" />
      <item value="keep away" />
      <item value="保持距离" />
      <item value="grain" />
      <item value="grained" />
      <item value="complaint" />
      <item value="complain" />
      <item value="compliant" />
      <item value="抱怨" />
      <item value="complient" />
      <item value="share out your money" />
      <item value="share out" />
      <item value="sliver" />
      <item value="slice" />
      <item value="dry" />
      <item value="overcook" />
      <item value="robbery" />
      <item value="in addable" />
      <item value="addable" />
      <item value="salty" />
      <item value="overthink" />
      <item value="runny nose" />
      <item value="更新备份策略的使用量 waitress waiter servant domestic runny nose overthean" />
      <item value="ronny nose" />
      <item value="nose" />
      <item value="ronny noise" />
      <item value="ronny" />
      <item value="domestic" />
      <item value="servant" />
      <item value="女服务员" />
      <item value="witters" />
      <item value="wateriness" />
      <item value="wait" />
      <item value="waiter" />
      <item value="how as" />
      <item value="throw in" />
      <item value="despite" />
      <item value="despot" />
      <item value="repaid" />
      <item value="repay" />
      <item value="rapid" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="AFRIKAANS" value="1" />
        <entry key="BENGALI" value="1" />
        <entry key="BULGARIAN" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="CEBUANO" value="1" />
        <entry key="CHICHEWA" value="1" />
        <entry key="CHINESE" value="1262" />
        <entry key="CORSICAN" value="1" />
        <entry key="DANISH" value="1" />
        <entry key="DUTCH" value="1" />
        <entry key="ENGLISH" value="1263" />
        <entry key="ESTONIAN" value="1" />
        <entry key="FILIPINO" value="3" />
        <entry key="FRENCH" value="5" />
        <entry key="GERMAN" value="1" />
        <entry key="HAITIAN_CREOLE" value="2" />
        <entry key="HAUSA" value="1" />
        <entry key="HAWAIIAN" value="1" />
        <entry key="HMONG" value="1" />
        <entry key="ITALIAN" value="4" />
        <entry key="JAPANESE" value="1" />
        <entry key="LATIN" value="4" />
        <entry key="LATVIAN" value="1" />
        <entry key="MALAGASY" value="2" />
        <entry key="MALAY" value="1" />
        <entry key="PORTUGUESE" value="3" />
        <entry key="ROMANIAN" value="1" />
        <entry key="RUSSIAN" value="1" />
        <entry key="SLOVENIAN" value="1" />
        <entry key="SPANISH" value="1" />
        <entry key="SWEDISH" value="3" />
        <entry key="UZBEK" value="3" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
</application>